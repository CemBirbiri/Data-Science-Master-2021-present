# -*- coding: utf-8 -*-
"""BasicTools_Exam_Ufuk_Cem_Birbiri

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1DRsW1WB1KwQe4MGCFZO2QLKJENf9p7jx

# 0- Start by copying the notebook, renaming the notebook with your name. When you finish the exercises please send them to :

hind.dadoun@inria.fr

1- Define a function **strong_password()** that asks a user to input a password, verifies if the password is strong (if so, returns True) and if not returns the minimum number of characters to make it strong.  

A password is considered to be strong if it satisfies the following criteria:

    Its length is at least 6. 
    It contains at least one digit.
    It contains at least one lowercase English character.
    It contains at least one uppercase English character.
    It contains at least one special character. The special characters are: !@#$%^&*()-+
"""

def strong_password(*pass_input):
  if pass_input==():
    passw= input()
  else:
    passw=pass_input[0]
  flag=[0,0,0,0,0]
  if len(passw)>=6:
    flag[0]=1
  
  #make lower letters as list
  lowers='abcdefghijklmnopqrstuvwxyz'
  uppers='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
  lowers_list=[]
  uppers_list=[]
  for i in range(0,len(lowers)):
    lowers_list.append(lowers[i])
    uppers_list.append(uppers[i])
  
  
  for i in range(0,len(passw)): 
    if type(passw[i]) is int:
      flag[1]=1
      break
  for i in range(0,len(passw)):
    if passw[i] in lowers_list:
      flag[2]=1
      break
  for i in range(0,len(passw)):
    if passw[i] in uppers_list:
      flag[3]=1
      break

  special_characters="!@#$%^&*()-+"
  special_characters_list=[]
  for i in range(0,len(special_characters)):
    special_characters_list.append(special_characters[i])
  for i in range(0,len(passw)):
    if passw[i] in special_characters_list:
      flag[4]=1
      break

  if flag==5:
    return True
  else:
    min_char_to_make_strong=0
    for i in range(0,len(flag)):
      if flag[i]==0:
        min_char_to_make_strong=min_char_to_make_strong+1
    #print(flag)
    return min_char_to_make_strong



strong_password("xxx")

"""2- Write a function **add_user()** that: \
 a- Takes as input a name (string) and a  password \
 b- Ensures that the first and last names of the user begin with a capital letter.\
 c- Verifies if the password is strong, otherwise asks again for a strong password. \
 d- Stores it in a global dictionnary where the key is : input name *white space* birth date and the value is a strong password. \
 e- If a user with the same name and birth date already exists, the function should add the the key the current datetime. 


Hint : To get the current time in python import the library datetime: 


```
datetime.now()
```
"""

import datetime

dict1={}
def add_user():
  #make lower letters as list
  lowers='abcdefghijklmnopqrstuvwxyz'
  uppers='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
  lowers_list=[]
  uppers_list=[]
  for i in range(0,len(lowers)):
    lowers_list.append(lowers[i])
    uppers_list.append(uppers[i])

  print("Give me your name")
  name=input()
  print("Give the birt date of yours")
  birth_date=input()
  print("Give ma a password")
  password=input()
  name_list=name.split(" ")
  if name_list[0][0] not in uppers_list and name_list[-1][0] not in uppers_list:
    print("The first and last names of the user SHOULD begin with a capital letter.")
    return
  if strong_password(password)!=True:
    print("Please give me a strong password")
    return
  
  
  key_temp1=""
  key_temp1= name+" "+birth_date
  if dict1.get(key_temp1)==1:
    today_date = datetime.now()
    key_temp2= str(today_date)
    dict1[key_temp2]=password
  else:
    dict1[key_temp1]=password
  return dict1

print(add_user())

"""3- You have access to an image of size 400x 400. To download it and resize it here is the code : 

```
import cv2
!gdown --id 1l-Dhk04SuXAs_5v52j_2KrvexIRGYF2O
image_bib = cv2.imread('/content/image_test2.jpg')
resized_image = cv2.resize(image_bib, (400,400), interpolation = cv2.INTER_AREA)
```

Each user can : \
  a - Crop the image by giving 4 coordinates of the region to crop. \
  b - Divide the image in N (N >= 2) squares and  swap the upper left square with the bottom left square in the image. \
  c - Ask to plot the resulting image or save it in JPEG format. 

Write a function that:
1 - Asks the user for the operation he wants to do (can only take as argument "crop" or "swap") and how he wants to see the image (can only take as argument "save" or "show"). \
2 - If the operation is "crop" asks the user for the coordinates of the region to crop and verifies that the coordinates are inside the image.  \
3 - If the operation is "swap" \
 a- Asks for the number of squares. \
 b- Verifies : \
*   if it is possible to divide the image in even squares (same height and width). If so, creates a new array where the squares are swapped.
*   else, outputs the error message "This image can not be devided in **number of input squares given** squares.
"""


#400x 400
import numpy as np
import copy
import cv2
from google.colab.patches import cv2_imshow 
!gdown --id 1l-Dhk04SuXAs_5v52j_2KrvexIRGYF2O
image_bib = cv2.imread('/content/image_test2.jpg')
resized_image = cv2.resize(image_bib, (400,400), interpolation = cv2.INTER_AREA)

def crop_function(how_u_wanna_see,image_bib):
  print("give me 8 numbers which will be coordinates")
  coords = input()
  coords=coords.split(" ")
  
  coordinates=[]
  for i in range(0,len(coords),2):
    coordinates.append(( int(coords[i]) , int(coords[i+1]) ))
  print(coordinates)
  for i in range(0,len(coordinates)):
    if coordinates[i][0] < 0 or coordinates[i][1]>400:
      print("Coordinates out of borders")
      return

  #crop_img = img[y:y+h, x:x+w]
  crop_img = image_bib[coordinates[0][1]:coordinates[1][1], coordinates[0][0]:coordinates[2][0]]
  if how_u_wanna_see=="save":
    path = '/content/savedImage.jpg'
    cv2.imwrite(path, crop_img)

  elif how_u_wanna_see=="show":
    
    cv2_imshow(crop_img)
    cv2.waitKey(0) 
    #closing all open windows 
    cv2.destroyAllWindows() 

def swap_function(how_u_wanna_see,image_bib):
  #if it is possible to divide the image in even squares (same height and width). 
  #If so, creates a new array where the squares are swapped.
  #else, outputs the error message "This image can not be devided in number of input squares given squares.
  print("How many squares you wanna divide the image??")
  num_squares= input()
  num_squares = int(num_squares)
  if num_squares%2!=0:
    print("ERROR: This image can not be devided in number of input squares given squares")
  else:
    coloms=[]
    c=0
    half=num_squares/2
    half=int(half)
    print(half, type(half))
    for i in range(0,half):
      coloms.append(c)
      c=c+ (400/(half))
    coloms.append(400)
    print("****",coloms)
    #[0, 80.0, 160.0, 240.0, 320.0, 400]
    #[0, 200.0, 400]
    
    image_bib_temp= copy.deepcopy(image_bib)
    print(type(image_bib))
    
    upper_left =image_bib[0:int(coloms[1]), 0:200]
    lower_right= image_bib[int(coloms[-2]):400, 200:400]

    
    image_bib_temp[0:int(coloms[1]), 0:200] = lower_right
    image_bib_temp[int(coloms[-2]):400, 200:400] = upper_left
    
    
    if how_u_wanna_see=="save":
      path = '/content/savedImage.jpg'
      cv2.imwrite(path, image_bib_temp)

    elif how_u_wanna_see=="show":
      
      cv2_imshow(image_bib_temp)
      cv2.waitKey(0) 
      #closing all open windows 
      cv2.destroyAllWindows() 

 


def f(operation, how_u_wanna_see,image_bib):
  if operation == "crop":
    crop_function(how_u_wanna_see,image_bib)
  else:
    swap_function(how_u_wanna_see,image_bib)

#0 0 0 200 100 0 100 200

f("swap", "show",resized_image)